# -*- coding: utf-8 -*-
"""
/***************************************************************************
 S111Viewer
                                 A QGIS plugin
 S-111 海洋數據可視化與動畫插件 - 增強版
 支持多檔案讀取和S-111標準箭頭渲染
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-05-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by NTOU
        email                : steven65026502@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import sys
import traceback

# 添加 DLL 搜索路徑
plugin_dir = os.path.dirname(os.path.abspath(__file__))
dll_path = os.path.join(plugin_dir, 'dll')
if os.path.exists(dll_path):
    if sys.platform == 'win32' and 'PATH' in os.environ:
        os.environ['PATH'] = dll_path + os.pathsep + os.environ['PATH']
        print(f"已將 {dll_path} 添加到 PATH 環境變量")

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QTimer, QVariant
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, 
    QgsPointXY, QgsField, QgsSingleSymbolRenderer, QgsSymbol,
    QgsMarkerSymbol, QgsProperty, QgsArrowSymbolLayer, QgsRuleBasedRenderer, QgsLineSymbol, QgsLineString, QgsPoint, QgsFields, QgsSymbolLayer
)
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import (QAction, QFileDialog, QMessageBox, QColorDialog, 
                                QPushButton, QListWidget, QVBoxLayout, QHBoxLayout, 
                                QWidget, QLabel, QListWidgetItem)
from qgis.core import QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, QgsPointXY

# Initialize Qt resources from file resources.py
from .resources import *

# 導入必要的庫
import os.path
import numpy as np
import math

# 嘗試導入 h5py，帶詳細錯誤報告
try:
    import h5py
    H5PY_AVAILABLE = True
    print(f"成功導入 h5py，版本: {h5py.__version__}")
    print(f"h5py 路徑: {h5py.__file__}")
except ImportError as e:
    print(f"無法導入 h5py: {e}")
    h5py = None
    H5PY_AVAILABLE = False
except Exception as e:
    print(f"導入 h5py 時出錯: {e}")
    print(traceback.format_exc())
    h5py = None
    H5PY_AVAILABLE = False

# S-111 標準常量和函數
class S111Standards:
    """S-111 標準規範類"""
    
    # 箭頭大小計算參數 (根據 S-111 標準 Table 9-3)
    HREF = 10.0  # 參考高度 (mm)
    SREF = 5.0   # 參考速度 (kn)
    SLOW = 2.0   # 最小速度 (kn)
    SHIGH = 13.0 # 最大速度 (kn)
    
    # 速度帶顏色方案 (根據 S-111 標準 Table 9-2)
    SPEED_BANDS = [
        (0.0, 0.5, '#7652E2'),   # Band 1: Purple
        (0.5, 1.0, '#4898D3'),   # Band 2: Dark Blue
        (1.0, 2.0, '#61CBE5'),   # Band 3: Light Blue
        (2.0, 3.0, '#6DBC45'),   # Band 4: Dark Green
        (3.0, 5.0, '#B4DC00'),   # Band 5: Light Green
        (5.0, 7.0, '#CDC100'),   # Band 6: Yellow-Green
        (7.0, 10.0, '#F8A718'),  # Band 7: Orange
        (10.0, 13.0, '#F7A29D'), # Band 8: Pink
        (13.0, float('inf'), '#FF1E1E')  # Band 9: Red
    ]
    
    @staticmethod
    def get_speed_band_color(speed_kn):
        """根據速度獲取對應的顏色"""
        for min_speed, max_speed, color in S111Standards.SPEED_BANDS:
            if min_speed <= speed_kn < max_speed:
                return color
        return '#000000'  # 默認黑色
    
    @staticmethod
    def calculate_arrow_size_mm(speed_kn):
        """根據 S-111 標準計算箭頭大小 (mm)"""
        if speed_kn <= S111Standards.SLOW:
            return S111Standards.HREF * (speed_kn / S111Standards.SLOW)
        elif speed_kn >= S111Standards.SHIGH:
            return S111Standards.HREF * (speed_kn / S111Standards.SREF)
        else:
            return S111Standards.HREF
    
    @staticmethod
    def mm_to_map_units(mm_size, scale_factor=0.5):
        """將毫米轉換為地圖單位"""
        return mm_size * scale_factor
    
    @staticmethod
    def get_speed_band_info(speed_kn):
        """獲取速度帶資訊
        
        Args:
            speed_kn (float): 速度值(節)
            
        Returns:
            tuple: (帶編號, 顏色, 大小mm)
        """
        for i, (min_speed, max_speed, color) in enumerate(S111Standards.SPEED_BANDS):
            if min_speed <= speed_kn < max_speed:
                size_mm = S111Standards.calculate_arrow_size_mm(speed_kn)
                return (i + 1, color, size_mm)
        
        # 超出範圍的情況
        size_mm = S111Standards.calculate_arrow_size_mm(speed_kn)
        return (9, S111Standards.SPEED_BANDS[-1][2], size_mm)
    
    @staticmethod
    def get_symbol_path():
        """獲取 S-111 標準符號的路徑
        
        Returns:
            str: 符號目錄的完整路徑
        """
        # 獲取插件目錄
        plugin_dir = os.path.dirname(os.path.abspath(__file__))
        # 構建符號目錄路徑
        symbol_dir = os.path.join(plugin_dir, 'S-111', 'CATALOGUES', '111_Portrayal_Catalogue_2.0.0', 'PC', 'XSLT', 'Symbols')
        return symbol_dir
    
    @staticmethod
    def get_arrow_symbol_path(band_number):
        """獲取指定速度帶的箭頭符號路徑
        
        Args:
            band_number (int): 速度帶編號 (1-9)
            
        Returns:
            str: SVG 符號文件的完整路徑
        """
        symbol_dir = S111Standards.get_symbol_path()
        return os.path.join(symbol_dir, f'SCAROW{band_number:02d}.svg')
    
    @staticmethod
    def get_color_style_path(style='day'):
        """獲取顏色樣式文件路徑
        
        Args:
            style (str): 樣式名稱 ('day', 'dusk', 'night')
            
        Returns:
            str: CSS 樣式文件的完整路徑
        """
        symbol_dir = S111Standards.get_symbol_path()
        return os.path.join(symbol_dir, f'SVGStyle_S111{style}.css')

# 創建增強的S111Reader類以處理多個S-111文件
class S111MultiFileReader:
    """S-111 多檔案讀取和管理類"""
    
    def __init__(self):
        """初始化多檔案讀取器"""
        self.files = {}  # 檔案字典: {filepath: S111Reader}
        self.current_file = None
        self.file_list = []  # 檔案路徑列表
        
    def add_files(self, filepaths):
        """添加多個S-111檔案
        
        Args:
            filepaths (list): 檔案路徑列表
            
        Returns:
            list: 成功載入的檔案路徑列表
        """
        successful_files = []
        
        for filepath in filepaths:
            reader = S111Reader()
            if reader.read_file(filepath):
                self.files[filepath] = reader
                self.file_list.append(filepath)
                successful_files.append(filepath)
                print(f"成功載入檔案: {os.path.basename(filepath)}")
            else:
                print(f"載入檔案失敗: {os.path.basename(filepath)}")
        
        # 設置第一個成功載入的檔案為當前檔案
        if successful_files and not self.current_file:
            self.current_file = successful_files[0]
            
        return successful_files
    
    def set_current_file(self, filepath):
        """設置當前活動檔案
        
        Args:
            filepath (str): 檔案路徑
        """
        if filepath in self.files:
            self.current_file = filepath
            print(f"切換到檔案: {os.path.basename(filepath)}")
        
    def get_current_reader(self):
        """獲取當前活動檔案的讀取器
        
        Returns:
            S111Reader: 當前檔案讀取器，若無則返回None
        """
        if self.current_file and self.current_file in self.files:
            return self.files[self.current_file]
        return None
    
    def get_file_info_list(self):
        """獲取檔案資訊列表
        
        Returns:
            list: [(檔案名, 檔案路徑, 時間點數量), ...]
        """
        info_list = []
        for filepath in self.file_list:
            reader = self.files[filepath]
            filename = os.path.basename(filepath)
            time_count = len(reader.time_points) if reader.time_points else 0
            info_list.append((filename, filepath, time_count))
        return info_list
    
    def remove_file(self, filepath):
        """移除檔案
        
        Args:
            filepath (str): 要移除的檔案路徑
        """
        if filepath in self.files:
            del self.files[filepath]
            self.file_list.remove(filepath)
            
            # 如果移除的是當前檔案，切換到下一個
            if filepath == self.current_file:
                self.current_file = self.file_list[0] if self.file_list else None

class S111Reader:
    """S-111 文件讀取和解析類"""
    
    def __init__(self):
        """初始化 S111Reader 對象"""
        self.filename = None
        self.metadata = {}
        self.surfaces = []  # 每個時間點的流速和方向數據
        self.time_points = []  # 時間點列表
        self.geotransform = None  # 地理參考信息
        
    def read_file(self, filename):
        """讀取 S-111 HDF5 文件
        
        Args:
            filename (str): S-111 文件路徑
            
        Returns:
            bool: 是否成功讀取文件
        """
        global h5py, H5PY_AVAILABLE
        if h5py is None or not H5PY_AVAILABLE:
            from qgis.PyQt.QtWidgets import QMessageBox
            QMessageBox.warning(
                None,
                "缺少依賴庫",
                "需要安裝 h5py 庫以讀取 S-111 文件。\n\n"
                "插件已嘗試加載 h5py 但失敗了。請查看 QGIS 日誌獲取詳細錯誤信息。"
            )
            return False
            
        self.filename = filename
        self.metadata = {}
        self.surfaces = []
        self.time_points = []
        self.geotransform = None
        
        try:
            # 添加調試信息
            print(f"嘗試打開文件: {filename}")
            
            # 使用更強大的錯誤處理打開文件
            try:
                f = h5py.File(filename, 'r')
            except OSError as e:
                print(f"無法打開 HDF5 文件: {e}")
                return False
            
            print("成功打開 HDF5 文件")
            
            # 調試: 打印文件的頂層結構
            print(f"HDF5 文件頂層結構: {list(f.keys())}")
            
            # 1. 先獲取並打印文件的所有屬性
            print("文件屬性:")
            for attr_name in f.attrs:
                attr_value = f.attrs[attr_name]
                print(f"  {attr_name}: {attr_value}")
                # 將屬性存儲到元數據字典
                if isinstance(attr_value, bytes):
                    try:
                        # 嘗試解碼為字符串
                        attr_value = attr_value.decode('utf-8', errors='replace')
                    except:
                        pass
                self.metadata[attr_name] = attr_value
            
            # 2. 遞歸探索 HDF5 文件結構
            def explore_group(group, prefix=""):
                """遞歸探索 HDF5 組並打印結構"""
                for key in group:
                    item = group[key]
                    item_path = f"{prefix}/{key}"
                    if isinstance(item, h5py.Group):
                        print(f"組: {item_path}")
                        # 打印組的屬性
                        for attr_name in item.attrs:
                            print(f"  屬性 {attr_name}: {item.attrs[attr_name]}")
                        explore_group(item, item_path)
                    elif isinstance(item, h5py.Dataset):
                        print(f"數據集: {item_path}, 形狀: {item.shape}, 類型: {item.dtype}")
                        # 打印數據集的屬性
                        for attr_name in item.attrs:
                            print(f"  屬性 {attr_name}: {item.attrs[attr_name]}")
            
            # 執行遞歸探索
            print("\n開始探索 HDF5 文件結構:")
            explore_group(f)
            
            # 3. 尋找並讀取表面流速數據
            # 根據 S-111 標準結構，但增加靈活性以處理可能的變化
            
            # 首先嘗試標準 S-111 結構
            if 'SurfaceCurrent' in f:
                print("\n找到 SurfaceCurrent 組，嘗試讀取標準結構...")
                self._read_standard_s111(f)
            else:
                # 嘗試備用方法，搜索任何包含速度和方向的數據集
                print("\n未找到標準 SurfaceCurrent 組，嘗試搜索任何流速數據...")
                self._search_for_current_data(f)
            
            # 嘗試設置地理參考信息
            self._set_geotransform(f)
            
            # 關閉文件
            f.close()
            
            # 檢查是否成功讀取了數據
            if len(self.surfaces) > 0:
                print(f"成功讀取 {len(self.surfaces)} 個時間點的數據")
                print(f"時間點列表: {self.time_points}")
                return True
            else:
                print("未能讀取任何有效的流速數據")
                return False
                
        except Exception as e:
            print(f"讀取 S-111 文件時發生異常: {e}")
            print(traceback.format_exc())
            return False

    def _read_standard_s111(self, file_obj):
        """嘗試按照標準 S-111 結構讀取數據"""
        current_group = file_obj['SurfaceCurrent']
        
        # 檢查是否有 SurfaceCurrent.01 結構
        if 'SurfaceCurrent.01' in current_group:
            current_group = current_group['SurfaceCurrent.01']
            print("找到 SurfaceCurrent.01 組")
        
        # 查找所有時間組
        groups = []
        for group_name in current_group:
            if group_name.startswith('Group_'):
                groups.append(group_name)
                
        if not groups:
            print("在 SurfaceCurrent 中未找到標準 Group_ 組")
            # 檢查是否可能有直接數據
            if 'surfaceCurrentSpeed' in current_group and 'surfaceCurrentDirection' in current_group:
                print("在 SurfaceCurrent 根組中直接找到數據")
                try:
                    speed = current_group['surfaceCurrentSpeed'][()]
                    direction = current_group['surfaceCurrentDirection'][()]
                    # 將數據上下翻轉
                    speed_flipped = np.flipud(speed)
                    direction_flipped = np.flipud(direction)
                    # 如果找不到時間數據，使用默認值 0
                    self.time_points.append(0)
                    self.surfaces.append((speed_flipped, direction_flipped))
                    print(f"已讀取單個時間點的數據，速度形狀: {speed.shape}（已上下翻轉）")
                except Exception as e:
                    print(f"讀取直接數據時出錯: {e}")
            return
        
        # 按數字順序排序組
        try:
            groups.sort(key=lambda x: int(x.split('_')[1]))
        except:
            # 如果排序失敗，保持原有順序
            print("組排序失敗，使用原有順序")
        
        print(f"找到時間組: {groups}")
        
        # 讀取每個時間組的數據
        for group_name in groups:
            group = current_group[group_name]
            
            try:
                # 讀取時間值
                time_value = None
                for time_field in ['timePoint', 'timepoint', 'time', 'Time']:
                    if time_field in group.attrs:
                        time_value = group.attrs[time_field]
                        if isinstance(time_value, bytes):
                            time_value = time_value.decode('utf-8', errors='replace')
                        print(f"從屬性 {time_field} 讀取時間值: {time_value}")
                        break
                    elif time_field in group:
                        time_value = group[time_field][()]
                        if isinstance(time_value, bytes):
                            time_value = time_value.decode('utf-8', errors='replace')
                        print(f"從數據集 {time_field} 讀取時間值: {time_value}")
                        break
                
                if time_value is None:
                    time_value = len(self.time_points)
                    print(f"未找到時間數據，使用索引: {time_value}")
                
                # 讀取流速和方向
                speed = None
                direction = None
                
                # 嘗試讀取 values 數據集（結構化數組）
                if 'values' in group:
                    values = group['values'][()]
                    print(f"找到 values 數據集，類型: {values.dtype}")
                    
                    if 'surfaceCurrentSpeed' in values.dtype.names and 'surfaceCurrentDirection' in values.dtype.names:
                        speed = values['surfaceCurrentSpeed']
                        direction = values['surfaceCurrentDirection']
                        print(f"從 values 數據集讀取流速和方向數據，形狀: {speed.shape}")
                else:
                    # 嘗試單獨讀取速度和方向數據集
                    for speed_field in ['surfaceCurrentSpeed', 'currentSpeed', 'speed', 'Speed']:
                        if speed_field in group:
                            speed = group[speed_field][()]
                            print(f"從 {speed_field} 讀取速度數據，形狀: {speed.shape}")
                            break
                    
                    for dir_field in ['surfaceCurrentDirection', 'currentDirection', 'direction', 'Direction']:
                        if dir_field in group:
                            direction = group[dir_field][()]
                            print(f"從 {dir_field} 讀取方向數據，形狀: {direction.shape}")
                            break
                
                if speed is not None and direction is not None:
                    speed_flipped = np.flipud(speed)
                    direction_flipped = np.flipud(direction)
                    self.time_points.append(time_value)
                    self.surfaces.append((speed_flipped, direction_flipped))
                    print(f"成功讀取時間點 {time_value} 的數據（已上下翻轉）")
                else:
                    print(f"組 {group_name} 中未找到有效的速度或方向數據")
                    
            except Exception as e:
                print(f"處理組 {group_name} 時出錯: {e}")
                print(traceback.format_exc())

    def _search_for_current_data(self, file_obj):
        """搜索任何可能的流速數據"""
        # 定義將要搜索的數據集名稱模式
        speed_patterns = ['speed', 'Speed', 'current', 'Current', 'velocity', 'Velocity']
        direction_patterns = ['direction', 'Direction', 'angle', 'Angle', 'bearing', 'Bearing']
        
        # 存儲找到的候選數據集
        speed_candidates = []
        direction_candidates = []
        
        def scan_for_datasets(group, prefix=""):
            """遞歸掃描組查找可能的數據集"""
            for key in group:
                item = group[key]
                item_path = f"{prefix}/{key}" if prefix else key
                
                if isinstance(item, h5py.Group):
                    scan_for_datasets(item, item_path)
                elif isinstance(item, h5py.Dataset):
                    # 檢查數據集是否可能是速度或方向
                    item_name = key.lower()
                    
                    # 檢查是否是數值類型
                    if not np.issubdtype(item.dtype, np.number):
                        continue
                        
                    # 檢查數據集名稱
                    is_speed = any(pattern.lower() in item_name for pattern in speed_patterns)
                    is_direction = any(pattern.lower() in item_name for pattern in direction_patterns)
                    
                    if is_speed and not is_direction:
                        print(f"找到可能的速度數據集: {item_path}, 形狀: {item.shape}")
                        speed_candidates.append((item_path, item))
                    elif is_direction and not is_speed:
                        print(f"找到可能的方向數據集: {item_path}, 形狀: {item.shape}")
                        direction_candidates.append((item_path, item))
        
        # 執行掃描
        scan_for_datasets(file_obj)
        
        print(f"找到 {len(speed_candidates)} 個可能的速度數據集")
        print(f"找到 {len(direction_candidates)} 個可能的方向數據集")
        
        # 嘗試匹配速度和方向數據集
        if speed_candidates and direction_candidates:
            # 簡單的情況：只有一個速度和一個方向
            if len(speed_candidates) == 1 and len(direction_candidates) == 1:
                speed_path, speed_dataset = speed_candidates[0]
                dir_path, dir_dataset = direction_candidates[0]
                
                if speed_dataset.shape == dir_dataset.shape:
                    print(f"使用數據集: {speed_path} 和 {dir_path}")
                    # 將數據上下翻轉以修正方向問題
                    speed_data = np.flipud(speed_dataset[()])
                    direction_data = np.flipud(dir_dataset[()])
                    self.time_points.append(0)  # 使用單個時間點
                    self.surfaces.append((speed_data, direction_data))
                    print(f"成功讀取單個時間點的數據，形狀: {speed_dataset.shape}（已上下翻轉）")

                    
            # 複雜情況：多個數據集
            else:
                # 嘗試基於路徑相似性匹配
                for speed_path, speed_dataset in speed_candidates:
                    for dir_path, dir_dataset in direction_candidates:
                        if speed_dataset.shape != dir_dataset.shape:
                            continue
                            
                        # 檢查路徑相似性
                        speed_parts = speed_path.split('/')
                        dir_parts = dir_path.split('/')
                        
                        # 如果在同一組中或路徑非常相似
                        if speed_parts[:-1] == dir_parts[:-1] or speed_path.split('/')[0] == dir_path.split('/')[0]:
                            print(f"根據路徑相似性匹配數據集: {speed_path} 和 {dir_path}")
                            # 將數據上下翻轉以修正方向問題
                            speed_data = np.flipud(speed_dataset[()])
                            direction_data = np.flipud(dir_dataset[()])
                            self.time_points.append(len(self.time_points))
                            self.surfaces.append((speed_data, direction_data))
                            print(f"成功讀取數據，形狀: {speed_dataset.shape}（已上下翻轉）")

    def _set_geotransform(self, file_obj):
        """設置地理參考信息"""
        try:
            # 嘗試從不同來源獲取地理參考信息
            
            # 1. 首先嘗試從元數據獲取
            geo_fields = {
                'west': ['westBoundLongitude', 'west', 'xmin', 'lon_min'],
                'east': ['eastBoundLongitude', 'east', 'xmax', 'lon_max'],
                'north': ['northBoundLatitude', 'north', 'ymax', 'lat_max'],
                'south': ['southBoundLatitude', 'south', 'ymin', 'lat_min'],
                'xres': ['gridSpacingLongitudinal', 'xres', 'dx', 'lonRes'],
                'yres': ['gridSpacingLatitudinal', 'yres', 'dy', 'latRes']
            }
            
            geo_values = {}
            for key, field_names in geo_fields.items():
                for field in field_names:
                    if field in self.metadata:
                        geo_values[key] = self.metadata[field]
                        break
            
            # 2. 如果元數據不足，嘗試從文件結構中查找
            if len(geo_values) < 6:
                # 尋找 SurfaceCurrent 組，可能包含地理信息
                if 'SurfaceCurrent' in file_obj:
                    sc_group = file_obj['SurfaceCurrent']
                    
                    # 檢查是否有 SurfaceCurrent.01 子組
                    if 'SurfaceCurrent.01' in sc_group:
                        sc01_group = sc_group['SurfaceCurrent.01']
                        
                        # 嘗試從屬性獲取地理信息
                        for attr_name in sc01_group.attrs:
                            attr_lower = attr_name.lower()
                            for key, field_names in geo_fields.items():
                                if attr_lower in [fn.lower() for fn in field_names] and key not in geo_values:
                                    geo_values[key] = sc01_group.attrs[attr_name]
                                    print(f"從 SurfaceCurrent.01 屬性 {attr_name} 獲取地理值 {key}: {sc01_group.attrs[attr_name]}")
            
            # 3. 如果仍然缺少數據，使用默認值或估算值
            required_keys = ['west', 'north', 'xres', 'yres']
            missing_keys = [key for key in required_keys if key not in geo_values]
            
            if missing_keys:
                print(f"缺少必要的地理參考字段: {missing_keys}")
                
                # 如果我們有速度和方向數據，可以嘗試估算
                if self.surfaces:
                    if 'west' not in geo_values:
                        geo_values['west'] = 118.0  # 默認西經 (台灣附近)
                    if 'north' not in geo_values:
                        geo_values['north'] = 22.0   # 默認北緯 (台灣附近)
                    
                    # 使用數據形狀估算分辨率
                    speed, _ = self.surfaces[0]
                    height, width = speed.shape
                    
                    if 'east' in geo_values and 'west' in geo_values and 'xres' not in geo_values:
                        x_span = float(geo_values['east']) - float(geo_values['west'])
                        geo_values['xres'] = x_span / width
                    elif 'xres' not in geo_values:
                        geo_values['xres'] = 0.01  # 默認經度分辨率
                        
                    if 'north' in geo_values and 'south' in geo_values and 'yres' not in geo_values:
                        y_span = float(geo_values['north']) - float(geo_values['south'])
                        geo_values['yres'] = y_span / height
                    elif 'yres' not in geo_values:
                        geo_values['yres'] = 0.01  # 默認緯度分辨率
            
            # 設置地理變換信息
            if len(geo_values) >= 4 and all(k in geo_values for k in required_keys):
                self.geotransform = [
                    float(geo_values.get('west', 0)),
                    float(geo_values.get('xres', 1)),
                    0,
                    float(geo_values.get('north', 0)),
                    0,
                    -abs(float(geo_values.get('yres', 1)))  # 確保是負值
                ]
                print(f"成功設置地理參考信息: {self.geotransform}")
            else:
                print("無法設置地理參考信息，使用默認值")
                # 如果還是沒有足夠信息，使用簡單的默認值
                self.geotransform = [0, 0.01, 0, 0, 0, -0.01]
                
        except Exception as e:
            print(f"設置地理參考信息時出錯: {e}")
            print(traceback.format_exc())
            # 使用默認地理參考
            self.geotransform = [0, 0.01, 0, 0, 0, -0.01]
            
    def analyze_h5_file(self, filename):
        """詳細分析 HDF5 文件結構並返回結果"""
        if not H5PY_AVAILABLE:
            return "錯誤: h5py 庫未安裝，無法分析 HDF5 文件"
            
        try:
            with h5py.File(filename, 'r') as f:
                info = "HDF5 文件結構分析:\n\n"
                
                # 文件屬性
                info += "文件屬性:\n"
                for attr in f.attrs:
                    attr_value = f.attrs[attr]
                    if isinstance(attr_value, bytes):
                        try:
                            attr_value = attr_value.decode('utf-8', errors='replace')
                        except:
                            pass
                    info += f"  {attr}: {attr_value}\n"
                
                # 遞歸獲取組和數據集信息
                def get_item_info(name, item):
                    item_info = ""
                    if isinstance(item, h5py.Group):
                        item_info = f"組: {name}\n"
                        for attr in item.attrs:
                            attr_value = item.attrs[attr]
                            if isinstance(attr_value, bytes):
                                try:
                                    attr_value = attr_value.decode('utf-8', errors='replace')
                                except:
                                    pass
                            item_info += f"  屬性 {attr}: {attr_value}\n"
                    elif isinstance(item, h5py.Dataset):
                        item_info = f"數據集: {name}\n"
                        item_info += f"  形狀: {item.shape}, 類型: {item.dtype}\n"
                        # 顯示小型數據集的值
                        if len(item.shape) == 0 or (len(item.shape) == 1 and item.shape[0] < 10):
                            try:
                                value = item[()]
                                if isinstance(value, bytes):
                                    try:
                                        value = value.decode('utf-8', errors='replace')
                                    except:
                                        pass
                                item_info += f"  值: {value}\n"
                            except:
                                pass
                        for attr in item.attrs:
                            attr_value = item.attrs[attr]
                            if isinstance(attr_value, bytes):
                                try:
                                    attr_value = attr_value.decode('utf-8', errors='replace')
                                except:
                                    pass
                            item_info += f"  屬性 {attr}: {attr_value}\n"
                    return item_info
                
                # 收集所有項目信息
                all_items = {}
                
                def visit_item(name, item):
                    all_items[name] = get_item_info(name, item)
                    return None
                
                f.visititems(visit_item)
                
                # 按名稱排序並添加到信息
                for name in sorted(all_items.keys()):
                    info += all_items[name] + "\n"
                
                return info
                
        except Exception as e:
            error_info = f"分析 HDF5 文件時出錯: {e}\n\n"
            error_info += traceback.format_exc()
            return error_info
            
    def get_metadata_text(self):
        """獲取格式化的元數據文本
        
        Returns:
            str: 格式化的元數據文本
        """
        if not self.metadata:
            return "無元數據可用"
            
        text = "S-111 文件元數據:\n\n"
        
        # 添加關鍵元數據
        important_keys = [
            'productSpecification', 'issueDate', 'issueTime',
            'horizontalDatumReference', 'epoch', 'geographicIdentifier',
            'metadata', 'dataCoverage', 'dataType'
        ]
        
        # 首先添加重要元數據
        for key in important_keys:
            if key in self.metadata:
                value = self.metadata[key]
                if isinstance(value, bytes):
                    value = value.decode('utf-8', errors='ignore')
                text += f"{key}: {value}\n"
        
        # 添加其他元數據
        for key, value in self.metadata.items():
            if key not in important_keys:
                if isinstance(value, bytes):
                    value = value.decode('utf-8', errors='ignore')
                text += f"{key}: {value}\n"
        
        # 添加時間點信息
        if self.time_points:
            text += f"\n時間序列: {len(self.time_points)} 個時間點\n"
            text += f"起始時間: {self.time_points[0]}\n"
            text += f"結束時間: {self.time_points[-1]}\n"
        
        return text

# 導入 S111ViewerDialog 類
try:
    from .s111_viewer_dialog import S111ViewerDialog
except ImportError as e:
    print(f"導入 S111ViewerDialog 時出錯: {e}")
    from qgis.PyQt.QtWidgets import QMessageBox
    QMessageBox.critical(
        None,
        "導入錯誤",
        f"無法導入 S111ViewerDialog 類: {e}\n請確保文件名和類名正確"
    )


class S111Viewer:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'S111Viewer_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&S-111 Viewer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        
        # 初始化實例變量（增強版）
        self.dlg = None
        self.multi_reader = None  # 改為多檔案讀取器
        self.current_file = None
        self.layers = []
        self.animation_timer = None
        self.arrow_color = QColor(0, 0, 255)  # 默認藍色（將被S-111標準顏色覆蓋）
        
        # 創建日志目錄
        self.log_dir = os.path.join(self.plugin_dir, 'logs')
        if not os.path.exists(self.log_dir):
            os.makedirs(self.log_dir)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('S111Viewer', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar."""

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/s111_viewer/icon.png'  # 修正連字符
        self.add_action(
            icon_path,
            text=self.tr(u'S-111 Viewer'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&S-111 Viewer'),
                action)
            self.iface.removeToolBarIcon(action)
            
        # 清理圖層
        self.clear_layers()

    def clear_layers(self):
        """清除所有已創建的圖層"""
        for layer_id in self.layers:
            QgsProject.instance().removeMapLayer(layer_id)
        self.layers = []

    def log_error(self, message, show_dialog=True):
        """記錄錯誤信息到日志文件並可選擇性地顯示對話框"""
        import datetime
        
        log_file = os.path.join(self.log_dir, 's111viewer_errors.log')
        
        with open(log_file, 'a', encoding='utf-8') as f:
            timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            f.write(f"[{timestamp}] {message}\n")
            f.write(traceback.format_exc())
            f.write("\n" + "-"*50 + "\n")
        
        if show_dialog:
            QMessageBox.critical(
                self.dlg,
                self.tr('錯誤'),
                self.tr('發生錯誤: {}。\n詳細錯誤已記錄到插件目錄中的日志文件。').format(message)
            )

    def check_dependencies(self):
        """檢查必要的依賴庫"""
        try:
            import h5py
            return True
        except (ImportError, Exception) as e:
            from qgis.PyQt.QtWidgets import QMessageBox
            QMessageBox.warning(
                self.dlg,
                self.tr('缺少依賴庫'),
                self.tr('無法載入 h5py 庫，這是讀取 S-111 文件所必需的。\n\n'
                      '錯誤信息: {}\n\n'
                      '為了安裝 h5py，請按照以下步驟操作：\n'
                      '1. 關閉 QGIS\n'
                      '2. 打開 OSGeo4W Shell（從開始菜單搜索）\n'
                      '3. 執行命令: pip install h5py\n'
                      '4. 重新啟動 QGIS').format(str(e))
            )
            return False

    def setup_dialog(self):
        """設置對話框並添加額外控件"""
        # 創建並添加「分析文件」按鈕
        if not hasattr(self.dlg, 'btnAnalyzeFile'):
            self.dlg.btnAnalyzeFile = QPushButton(self.tr('分析文件'), self.dlg)
            # 假設 btnBrowse 後面有空間放置這個按鈕
            browse_btn = self.dlg.btnBrowse
            layout = browse_btn.parentWidget().layout()
            # 找出 btnBrowse 在佈局中的位置
            index = -1
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.widget() == browse_btn:
                    index = i
                    break
            if index >= 0:
                # 在 btnBrowse 後面插入新按鈕
                layout.insertWidget(index + 1, self.dlg.btnAnalyzeFile)
                # 連接按鈕信號
                self.dlg.btnAnalyzeFile.clicked.connect(self.analyze_file)
                
        # 添加檔案列表控件
        self.setup_file_list_widget()

    def setup_file_list_widget(self):
        """設置檔案列表控件"""
        if not hasattr(self.dlg, 'fileListWidget'):
            # 創建檔案列表標籤和控件
            self.dlg.lblFileList = QLabel(self.tr('已載入檔案:'), self.dlg)
            self.dlg.fileListWidget = QListWidget(self.dlg)
            self.dlg.fileListWidget.setMaximumHeight(100)
            
            # 創建檔案管理按鈕
            self.dlg.btnRemoveFile = QPushButton(self.tr('移除檔案'), self.dlg)
            self.dlg.btnClearFiles = QPushButton(self.tr('清除全部'), self.dlg)
            
            # 連接信號
            self.dlg.fileListWidget.itemClicked.connect(self.on_file_selected)
            self.dlg.btnRemoveFile.clicked.connect(self.remove_selected_file)
            self.dlg.btnClearFiles.clicked.connect(self.clear_all_files)
            
            # 添加到佈局（假設有主佈局）
            try:
                # 找到主要的垂直佈局
                main_layout = self.dlg.layout()
                if main_layout:
                    # 添加檔案列表控件
                    main_layout.addWidget(self.dlg.lblFileList)
                    main_layout.addWidget(self.dlg.fileListWidget)
                    
                    # 創建按鈕水平佈局
                    button_layout = QHBoxLayout()
                    button_layout.addWidget(self.dlg.btnRemoveFile)
                    button_layout.addWidget(self.dlg.btnClearFiles)
                    
                    button_widget = QWidget()
                    button_widget.setLayout(button_layout)
                    main_layout.addWidget(button_widget)
            except Exception as e:
                print(f"設置檔案列表佈局時出錯: {e}")

    def select_files(self):
        """打開檔案選擇對話框選擇多個S-111檔案"""
        filenames, _ = QFileDialog.getOpenFileNames(
            self.dlg,
            self.tr('選擇 S-111 檔案'),
            '',
            self.tr('HDF5 檔案 (*.h5 *.hdf5);;所有檔案 (*)')
        )
        
        if filenames:
            # 初始化多檔案讀取器
            if not self.multi_reader:
                self.multi_reader = S111MultiFileReader()
            
            # 載入檔案
            successful_files = self.multi_reader.add_files(filenames)
            
            if successful_files:
                # 設定 current_file 為最新加入的檔案
                self.multi_reader.current_file = successful_files[-1]
                self.update_file_list()
                self.load_current_file()
                
                QMessageBox.information(
                    self.dlg,
                    self.tr('檔案載入完成'),
                    self.tr('成功載入 {} 個檔案，共 {} 個檔案。').format(
                        len(successful_files), len(filenames)
                    )
                )
            else:
                QMessageBox.warning(
                    self.dlg,
                    self.tr('載入錯誤'),
                    self.tr('未能載入任何檔案。請檢查檔案格式是否正確。')
                )

    def update_file_list(self):
        """更新檔案列表顯示"""
        if hasattr(self.dlg, 'fileListWidget') and self.multi_reader:
            self.dlg.fileListWidget.clear()
            
            file_info_list = self.multi_reader.get_file_info_list()
            for filename, filepath, time_count in file_info_list:
                # 創建列表項目
                item_text = f"{filename} ({time_count} 時間點)"
                item = QListWidgetItem(item_text)
                item.setData(Qt.UserRole, filepath)  # 存儲完整路徑
                
                # 如果是當前活動檔案，高亮顯示
                if filepath == self.multi_reader.current_file:
                    item.setBackground(QColor(200, 255, 200))  # 淺綠色背景
                    
                self.dlg.fileListWidget.addItem(item)

    def on_file_selected(self, item):
        """當用戶選擇檔案列表中的項目時"""
        filepath = item.data(Qt.UserRole)
        if filepath and self.multi_reader:
            # 切換到選擇的檔案
            self.multi_reader.set_current_file(filepath)
            self.update_file_list()  # 更新高亮顯示
            self.load_current_file()  # 載入新的當前檔案

    def remove_selected_file(self):
        """移除選擇的檔案"""
        if hasattr(self.dlg, 'fileListWidget'):
            current_item = self.dlg.fileListWidget.currentItem()
            if current_item and self.multi_reader:
                filepath = current_item.data(Qt.UserRole)
                self.multi_reader.remove_file(filepath)
                self.update_file_list()
                
                # 如果還有檔案，載入新的當前檔案
                if self.multi_reader.file_list:
                    self.load_current_file()
                else:
                    # 沒有檔案了，清空顯示
                    self.clear_layers()
                    if hasattr(self.dlg, 'txtMetadata'):
                        self.dlg.txtMetadata.clear()

    def clear_all_files(self):
        """清除所有檔案"""
        if self.multi_reader:
            self.multi_reader.files.clear()
            self.multi_reader.file_list.clear()
            self.multi_reader.current_file = None
            self.update_file_list()
            self.clear_layers()
            if hasattr(self.dlg, 'txtMetadata'):
                self.dlg.txtMetadata.clear()

    def load_current_file(self):
        """載入當前選擇的檔案並顯示數據"""
        if not self.multi_reader or not self.multi_reader.current_file:
            print("錯誤: 沒有選擇檔案")
            return
            
        try:
            current_reader = self.multi_reader.get_current_reader()
            if not current_reader:
                print("錯誤: 無法獲取當前讀取器")
                return
                
            # 獲取時間點數量
            time_count = len(current_reader.time_points)
            if time_count == 0:
                print("錯誤: 沒有時間點數據")
                return
                
            # 更新時間滑塊
            if hasattr(self.dlg, 'sliderTime'):
                self.dlg.sliderTime.setMaximum(time_count - 1)
                self.dlg.sliderTime.setValue(0)
                self.dlg.sliderTime.setEnabled(True)
                
            # 更新時間標籤
            if hasattr(self.dlg, 'lblCurrentTime'):
                self.dlg.lblCurrentTime.setText(str(current_reader.time_points[0]))
                
            # 創建向量圖層
            self.create_vector_layer(0)
            
            # 更新元數據顯示
            if hasattr(self.dlg, 'txtMetadata'):
                self.dlg.txtMetadata.setText(current_reader.get_metadata_text())
                
        except Exception as e:
            print(f"載入檔案時出錯: {e}")
            print(traceback.format_exc())
            self.log_error(f'載入當前檔案時發生錯誤: {str(e)}')

    def analyze_file(self):
        """分析當前選擇的 HDF5 文件"""
        if self.multi_reader and self.multi_reader.current_file:
            filename = self.multi_reader.current_file
        else:
            QMessageBox.warning(
                self.dlg,
                self.tr('錯誤'),
                self.tr('請先選擇一個 HDF5 文件')
            )
            return
        
        QMessageBox.information(
            self.dlg,
            self.tr('分析'),
            self.tr('正在分析文件結構，這可能需要一些時間...')
        )
        
        # 執行分析
        current_reader = self.multi_reader.get_current_reader()
        if current_reader:
            analysis_result = current_reader.analyze_h5_file(filename)
            
            # 顯示分析結果
            if hasattr(self.dlg, 'txtMetadata'):
                self.dlg.txtMetadata.setText(analysis_result)
            
            QMessageBox.information(
                self.dlg,
                self.tr('分析完成'),
                self.tr('文件結構分析已完成，請查看元數據區域以獲取詳細信息')
            )
            
    def layer_exists(self, layer_name):
        """檢查圖層名稱是否已存在於 QGIS"""
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == layer_name:
                return True
        return False

    def remove_old_s111_flow_layers(self, file_code):
        """移除所有同一檔案（不管時間步）的 S111_Flow 圖層"""
        project = QgsProject.instance()
        layers_to_remove = []
        prefix = f'S111_Flow_{file_code}'
        for layer in project.mapLayers().values():
            if layer.name().startswith(prefix):
                layers_to_remove.append(layer.id())
        for lid in layers_to_remove:
            project.removeMapLayer(lid)
        self.layers = []

    def create_vector_layer(self, time_index):
        """創建向量圖層顯示指定時間點的海流數據"""
        print(f"create_vector_layer 被調用: 時間索引 = {time_index}")
        
        if not self.multi_reader:
            print("錯誤: multi_reader 不存在")
            return None
            
        current_reader = self.multi_reader.get_current_reader()
        if not current_reader:
            print("錯誤: 當前讀取器不存在")
            return None
            
        if not current_reader.surfaces:
            print("錯誤: 沒有表面數據")
            return None
            
        if time_index >= len(current_reader.surfaces):
            print(f"錯誤: 時間索引 {time_index} 超出範圍 0-{len(current_reader.surfaces)-1}")
            return None
        
        # 圖層名稱
        filename = os.path.basename(self.multi_reader.current_file)
        layer_name = f"S111_Flow_{filename}_{time_index}"
        if self.layer_exists(layer_name):
            print(f"圖層 {layer_name} 已存在，跳過新增。")
            return
        
        try:
            # 在加新圖層前先移除舊的 S111_Flow 圖層
            self.remove_old_s111_flow_layers(filename)
            
            # 獲取當前時間點的數據
            surface_data = current_reader.surfaces[time_index]
            speed, direction = surface_data
            
            # 獲取地理參考信息
            geotransform = current_reader.geotransform
            if not geotransform:
                print("警告: 沒有地理參考信息，使用默認值")
                geotransform = [118.0, 0.01, 0, 22.0, 0, -0.01]
            
            # 創建臨時向量圖層
            vl = QgsVectorLayer("Point?crs=EPSG:4326", layer_name, "memory")
            
            # 添加屬性
            fields = QgsFields()
            fields.append(QgsField("Speed", QVariant.Double))
            fields.append(QgsField("Direction", QVariant.Double))
            fields.append(QgsField("Source", QVariant.String))
            vl.dataProvider().addAttributes(fields)
            vl.updateFields()
            
            # 創建特徵
            features = []
            height, width = speed.shape
            step = max(1, min(height, width) // 30)  # 採樣步長
            
            for y in range(0, height, step):
                for x in range(0, width, step):
                    try:
                        s = float(speed[y, x])
                        d = float(direction[y, x])
                        # 過濾缺值
                        if s > 0 and s != -9999 and d != -9999:
                            # 計算地理坐標
                            lon = geotransform[0] + x * geotransform[1]
                            lat = geotransform[3] + y * geotransform[5]
                            
                            # 創建特徵
                            feature = QgsFeature()
                            feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(lon, lat)))
                            feature.setAttributes([s, d, filename])
                            features.append(feature)
                    except Exception as e:
                        continue
            
            # 添加特徵到圖層
            if features:
                vl.dataProvider().addFeatures(features)
                vl.updateExtents()
                
                # 設置符號
                self.apply_s111_standard_symbology(vl)
                
                # 添加到項目
                QgsProject.instance().addMapLayer(vl)
                self.layers.append(vl.id())
                
                # 縮放到所有圖層的範圍
                if time_index == 0:
                    self.zoom_to_all_layers()
                
                print(f"成功創建圖層 {layer_name}，包含 {len(features)} 個特徵")
                print("Speed max/min:", np.nanmax(speed), np.nanmin(speed))
                print("Direction max/min:", np.nanmax(direction), np.nanmin(direction))
                print("Feature count:", len(features))
                return vl.id()
            else:
                print("警告: 沒有有效的特徵被創建")
                return None
                
        except Exception as e:
            print(f"創建向量圖層時出錯: {e}")
            print(traceback.format_exc())
            return None

    def zoom_to_all_layers(self):
        """縮放到所有圖層的範圍"""
        if not self.layers:
            return
            
        # 創建一個空的範圍
        combined_extent = None
        
        # 合併所有圖層的範圍
        for layer_id in self.layers:
            layer = QgsProject.instance().mapLayer(layer_id)
            if layer:
                if combined_extent is None:
                    combined_extent = layer.extent()
                else:
                    combined_extent.combineExtentWith(layer.extent())
        
        # 設置地圖畫布的範圍
        if combined_extent:
            self.iface.mapCanvas().setExtent(combined_extent)
            self.iface.mapCanvas().refresh()

    def apply_s111_standard_symbology(self, layer):
        """應用 S-111 標準符號設置到圖層"""
        try:
            # 創建箭頭符號
            symbol = QgsMarkerSymbol.createSimple({
                'name': 'arrow',
                'color': '0,100,255',
                'outline_color': 'black',
                'outline_width': '0.5',
                'size': '5',
                'size_unit': 'MM'
            })
            
            # 設置箭頭大小基於速度 (使用 S-111 標準計算)
            size_expr = """
            CASE
                WHEN "Speed" <= 2.0 THEN 10.0 * ("Speed" / 2.0)
                WHEN "Speed" >= 13.0 THEN 10.0 * ("Speed" / 5.0)
                ELSE 10.0
            END
            """
            size_prop = QgsProperty.fromExpression(size_expr)
            symbol.symbolLayer(0).setDataDefinedProperty(QgsSymbolLayer.PropertySize, size_prop)
            
            # 設置箭頭方向 (真北為0度，順時針為正)
            angle_prop = QgsProperty.fromExpression('"Direction"')
            symbol.symbolLayer(0).setDataDefinedProperty(QgsSymbolLayer.PropertyAngle, angle_prop)
            
            # 設置箭頭顏色基於速度帶
            color_expr = """
            CASE
                WHEN "Speed" <= 0.5 THEN '#7652E2'
                WHEN "Speed" <= 1.0 THEN '#4898D3'
                WHEN "Speed" <= 2.0 THEN '#61CBE5'
                WHEN "Speed" <= 3.0 THEN '#6DBC45'
                WHEN "Speed" <= 5.0 THEN '#B4DC00'
                WHEN "Speed" <= 7.0 THEN '#CDC100'
                WHEN "Speed" <= 10.0 THEN '#F8A718'
                WHEN "Speed" <= 13.0 THEN '#F7A29D'
                ELSE '#FF1E1E'
            END
            """
            color_prop = QgsProperty.fromExpression(color_expr)
            symbol.symbolLayer(0).setDataDefinedProperty(QgsSymbolLayer.PropertyFillColor, color_prop)
            
            # 應用渲染器
            renderer = QgsSingleSymbolRenderer(symbol)
            layer.setRenderer(renderer)
            
            # 觸發重繪
            layer.triggerRepaint()
            print("成功應用 S-111 標準箭頭符號")
            
        except Exception as e:
            print(f"應用符號時出錯: {e}")
            print(traceback.format_exc())
            # 使用簡單符號作為備用
            self.apply_simple_arrow_symbology(layer)

    def apply_simple_arrow_symbology(self, layer):
        """應用簡單的箭頭符號（備用方案）"""
        try:
            # 創建基本箭頭符號
            symbol = QgsMarkerSymbol.createSimple({
                'name': 'arrow',
                'color': '0,100,255',
                'outline_color': 'black',
                'outline_width': '0.5',
                'size': '5',
                'size_unit': 'MM'
            })
            
            # 設置基本大小和方向
            symbol.symbolLayer(0).setDataDefinedProperty(QgsSymbolLayer.PropertySize, QgsProperty.fromExpression('"Speed" * 2'))
            symbol.symbolLayer(0).setDataDefinedProperty(QgsSymbolLayer.PropertyAngle, QgsProperty.fromExpression('90 - "Direction"'))
            
            # 應用渲染器
            renderer = QgsSingleSymbolRenderer(symbol)
            layer.setRenderer(renderer)
            
            # 觸發重繪
            layer.triggerRepaint()
            print("成功應用簡單箭頭符號")
            
        except Exception as e:
            print(f"應用簡單箭頭符號時出錯: {e}")
            print(traceback.format_exc())
        
    def start_animation(self):
        """開始播放動畫"""
        print("開始播放動畫函數被調用")
        
        if not self.multi_reader:
            print("錯誤: multi_reader 不存在")
            return
            
        current_reader = self.multi_reader.get_current_reader()
        if not current_reader:
            print("錯誤: 沒有當前讀取器")
            return
            
        if not current_reader.surfaces:
            print("錯誤: 沒有表面數據")
            return
                
        print(f"時間點數量: {len(current_reader.surfaces)}")
        print(f"時間點列表: {current_reader.time_points}")
        
        if not self.animation_timer:
            self.animation_timer = QTimer()
            self.animation_timer.timeout.connect(self.next_frame)
            
        # 設置動畫速度
        interval = 500  # 毫秒
        self.animation_timer.start(interval)
        print(f"動畫計時器已啟動，間隔: {interval}ms")
        
        # 禁用某些控件
        if hasattr(self.dlg, 'btnPlay'):
            self.dlg.btnPlay.setEnabled(False)
        if hasattr(self.dlg, 'btnPause'):
            self.dlg.btnPause.setEnabled(True)
        if hasattr(self.dlg, 'btnStop'):
            self.dlg.btnStop.setEnabled(True)
        
    def pause_animation(self):
        """暫停動畫"""
        print("暫停動畫函數被調用")
        
        if self.animation_timer and self.animation_timer.isActive():
            self.animation_timer.stop()
            print("動畫計時器已停止")
            
        # 啟用播放按鈕
        if hasattr(self.dlg, 'btnPlay'):
            self.dlg.btnPlay.setEnabled(True)
        if hasattr(self.dlg, 'btnPause'):
            self.dlg.btnPause.setEnabled(False)
        
    def stop_animation(self):
        """停止動畫並重置"""
        print("停止動畫函數被調用")
        
        if self.animation_timer:
            self.animation_timer.stop()
            print("動畫計時器已停止")
        
        # 重置到第一幀
        if hasattr(self.dlg, 'sliderTime') and self.dlg.sliderTime.maximum() >= 0:
            print("重置到第一幀")
            self.dlg.sliderTime.setValue(0)
            
        # 啟用播放按鈕
        if hasattr(self.dlg, 'btnPlay'):
            self.dlg.btnPlay.setEnabled(True)
        if hasattr(self.dlg, 'btnPause'):
            self.dlg.btnPause.setEnabled(False)
        if hasattr(self.dlg, 'btnStop'):
            self.dlg.btnStop.setEnabled(False)
        
    def next_frame(self):
        """顯示下一幀"""
        if not hasattr(self.dlg, 'sliderTime'):
            return
            
        current = self.dlg.sliderTime.value()
        max_value = self.dlg.sliderTime.maximum()
        
        print(f"next_frame 被調用: 當前={current}, 最大={max_value}")
        
        # 保存當前視圖範圍
        current_extent = self.iface.mapCanvas().extent()
        
        if current < max_value:
            next_value = current + 1
            print(f"前進到下一幀: {next_value}")
            self.dlg.sliderTime.setValue(next_value)
        else:
            # 循環播放
            print("重置到第一幀")
            self.dlg.sliderTime.setValue(0)
            
        # 恢復視圖範圍
        self.iface.mapCanvas().setExtent(current_extent)
        self.iface.mapCanvas().refresh()
            
    def update_time_display(self, value):
        """更新時間顯示和當前顯示的圖層"""
        print(f"update_time_display 被調用: 時間索引 = {value}")
        
        if not self.multi_reader:
            print("錯誤: multi_reader 不存在")
            return
            
        current_reader = self.multi_reader.get_current_reader()
        if not current_reader:
            print("錯誤: 沒有當前讀取器")
            return
            
        if not current_reader.time_points:
            print("錯誤: 沒有時間點數據")
            return
            
        if 0 <= value < len(current_reader.time_points):
            # 保存當前視圖範圍
            current_extent = self.iface.mapCanvas().extent()
            
            # 更新時間標籤
            time_str = str(current_reader.time_points[value])
            print(f"設置時間標籤: {time_str}")
            if hasattr(self.dlg, 'lblCurrentTime'):
                self.dlg.lblCurrentTime.setText(time_str)
            
            # 更新顯示的圖層
            print(f"創建時間索引 {value} 的向量圖層")
            self.create_vector_layer(value)
            
            # 恢復視圖範圍
            self.iface.mapCanvas().setExtent(current_extent)
            self.iface.mapCanvas().refresh()
        else:
            print(f"錯誤: 時間索引 {value} 超出範圍 0-{len(current_reader.time_points)-1}")

    def update_arrow_size(self, size):
        """更新箭頭大小（在S-111標準模式下此功能被標準化）"""
        print(f"update_arrow_size 被調用: 大小 = {size}")
        print("注意: 在S-111標準模式下，箭頭大小由速度值自動計算")
        
        # 在S-111標準模式下，大小由速度自動決定，但可以作為縮放係數
        # 重新創建向量圖層以應用可能的縮放
        if hasattr(self.dlg, 'sliderTime'):
            current_time = self.dlg.sliderTime.value()
            if self.multi_reader and self.multi_reader.get_current_reader():
                print(f"重新創建時間索引 {current_time} 的向量圖層")
                self.create_vector_layer(current_time)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            try:
                self.dlg = S111ViewerDialog()
                
                # 初始化多檔案讀取器
                self.multi_reader = S111MultiFileReader()
                
                # 檢查依賴
                self.check_dependencies()
                
                # 設置對話框並添加額外控件
                self.setup_dialog()
                
                # 連接按鈕信號
                print("連接界面按鈕...")
                if hasattr(self.dlg, 'btnBrowse'):
                    self.dlg.btnBrowse.clicked.connect(self.select_files)  # 改為多檔案選擇
                    print("已連接瀏覽按鈕（多檔案模式）")
                else:
                    print("警告: 找不到 btnBrowse 按鈕")
                    
                if hasattr(self.dlg, 'btnPlay'):
                    self.dlg.btnPlay.clicked.connect(self.start_animation)
                    print("已連接播放按鈕")
                else:
                    print("警告: 找不到 btnPlay 按鈕")
                    
                if hasattr(self.dlg, 'btnPause'):
                    self.dlg.btnPause.clicked.connect(self.pause_animation)
                    print("已連接暫停按鈕")
                else:
                    print("警告: 找不到 btnPause 按鈕")
                    
                if hasattr(self.dlg, 'btnStop'):
                    self.dlg.btnStop.clicked.connect(self.stop_animation)
                    print("已連接停止按鈕")
                else:
                    print("警告: 找不到 btnStop 按鈕")
                    
                if hasattr(self.dlg, 'sliderTime'):
                    self.dlg.sliderTime.valueChanged.connect(self.update_time_display)
                    print("已連接時間滑塊")
                else:
                    print("警告: 找不到 sliderTime 滑塊")
                    
                if hasattr(self.dlg, 'spinArrowSize_2'):
                    self.dlg.spinArrowSize_2.valueChanged.connect(self.update_arrow_size)
                    print("已連接箭頭大小微調框 (spinArrowSize_2)")
                elif hasattr(self.dlg, 'spinArrowSize'):
                    self.dlg.spinArrowSize.valueChanged.connect(self.update_arrow_size)
                    print("已連接箭頭大小微調框 (spinArrowSize)")
                else:
                    print("警告: 找不到箭頭大小微調框")
                    
            except Exception as e:
                import traceback
                print(f"初始化插件時出錯: {e}")
                print(traceback.format_exc())
                return

        # show the dialog
        self.dlg.show()

    def remove_old_layers(self):
        """移除本插件加進來的所有圖層"""
        project = QgsProject.instance()
        for layer_id in self.layers:
            layer = project.mapLayer(layer_id)
            if layer:
                project.removeMapLayer(layer)
        self.layers = []