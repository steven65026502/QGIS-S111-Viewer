# -*- coding: utf-8 -*-
"""
/***************************************************************************
 S111Viewer
                                 A QGIS plugin
 S-111 海洋數據可視化與動畫插件
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-05-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by NTOU
        email                : steven65026502@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QTimer, QVariant
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, 
    QgsPointXY, QgsField, QgsSingleSymbolRenderer, QgsSymbol,
    QgsMarkerSymbol, QgsProperty, QgsArrowSymbolLayer
)
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QColorDialog
from qgis.core import QgsProject, QgsVectorLayer, QgsFeature, QgsGeometry, QgsPointXY

# Initialize Qt resources from file resources.py
from .resources import *

# 導入必要的庫
import os.path
import numpy as np
try:
    import h5py
except ImportError:
    h5py = None

# 創建 S111Reader 類以處理 S-111 文件
class S111Reader:
    """S-111 文件讀取和解析類"""
    
    def __init__(self):
        """初始化 S111Reader 對象"""
        self.filename = None
        self.metadata = {}
        self.surfaces = []  # 每個時間點的流速和方向數據
        self.time_points = []  # 時間點列表
        self.geotransform = None  # 地理參考信息
        
    def read_file(self, filename):
        """讀取 S-111 HDF5 文件
        
        Args:
            filename (str): S-111 文件路徑
            
        Returns:
            bool: 是否成功讀取文件
        """
        if not h5py:
            return False
            
        self.filename = filename
        self.metadata = {}
        self.surfaces = []
        self.time_points = []
        self.geotransform = None
        
        try:
            with h5py.File(filename, 'r') as f:
                # 獲取元數據
                for attr_name in f.attrs:
                    self.metadata[attr_name] = f.attrs[attr_name]
                
                # 獲取網格數據
                # S-111 標準中，數據可能存儲在不同的組和數據集中
                if 'SurfaceCurrent' in f:
                    current_group = f['SurfaceCurrent']
                    # 遍歷時間步驟
                    groups = []
                    for group_name in current_group:
                        if group_name.startswith('Group_'):
                            groups.append(group_name)
                    
                    # 按數字順序排序組
                    groups.sort(key=lambda x: int(x.split('_')[1]))
                    
                    for group_name in groups:
                        group = current_group[group_name]
                        
                        # 讀取時間值
                        if 'timePoint' in group:
                            self.time_points.append(group['timePoint'][()])
                        
                        # 讀取流速和方向數據
                        if 'surfaceCurrentSpeed' in group and 'surfaceCurrentDirection' in group:
                            speed = group['surfaceCurrentSpeed'][()]
                            direction = group['surfaceCurrentDirection'][()]
                            self.surfaces.append((speed, direction))
                
                # 獲取地理參考信息
                try:
                    # 這裡的具體字段名稱可能需要根據實際 S-111 文件調整
                    self.geotransform = [
                        self.metadata.get('westBoundLongitude', 0),  # 左上角經度
                        self.metadata.get('gridSpacingLongitudinal', 0),  # 經度方向像素大小
                        0,
                        self.metadata.get('northBoundLatitude', 0),  # 左上角緯度
                        0,
                        -self.metadata.get('gridSpacingLatitudinal', 0)  # 緯度方向像素大小
                    ]
                except:
                    self.geotransform = None
                
            return len(self.surfaces) > 0
            
        except Exception as e:
            print(f"讀取 S-111 文件錯誤: {e}")
            return False
            
    def get_metadata_text(self):
        """獲取格式化的元數據文本
        
        Returns:
            str: 格式化的元數據文本
        """
        if not self.metadata:
            return "無元數據可用"
            
        text = "S-111 文件元數據:\n\n"
        
        # 添加關鍵元數據
        important_keys = [
            'productSpecification', 'issueDate', 'issueTime',
            'horizontalDatumReference', 'epoch', 'geographicIdentifier',
            'metadata', 'dataCoverage', 'dataType'
        ]
        
        # 首先添加重要元數據
        for key in important_keys:
            if key in self.metadata:
                value = self.metadata[key]
                if isinstance(value, bytes):
                    value = value.decode('utf-8', errors='ignore')
                text += f"{key}: {value}\n"
        
        # 添加其他元數據
        for key, value in self.metadata.items():
            if key not in important_keys:
                if isinstance(value, bytes):
                    value = value.decode('utf-8', errors='ignore')
                text += f"{key}: {value}\n"
        
        # 添加時間點信息
        if self.time_points:
            text += f"\n時間序列: {len(self.time_points)} 個時間點\n"
            text += f"起始時間: {self.time_points[0]}\n"
            text += f"結束時間: {self.time_points[-1]}\n"
        
        return text

# 解決文件名中連字符問題的方法
# 注意：如果您重命名了文件，請相應修改以下導入語句
try:
    # 嘗試常規導入方式
    from .s111_viewer_dialog import S111ViewerDialog
except ImportError:
    try:
        # 嘗試帶連字符的導入方式
        s111_viewer_dialog = __import__('s111-viewer_dialog', globals(), locals(), ['S111ViewerDialog'], 0)
        S111ViewerDialog = s111_viewer_dialog.S111ViewerDialog
    except ImportError:
        # 如果都失敗，將在運行時顯示錯誤
        pass


class S111Viewer:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'S111Viewer_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&S-111 Viewer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        
        # 初始化實例變量
        self.dlg = None
        self.s111_reader = None
        self.current_file = None
        self.layers = []
        self.animation_timer = None
        self.arrow_color = QColor(0, 0, 255)  # 默認藍色

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('S111Viewer', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/s111-viewer/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'S-111 Viewer'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&S-111 Viewer'),
                action)
            self.iface.removeToolBarIcon(action)
            
        # 清理圖層
        self.clear_layers()

    def clear_layers(self):
        """清除所有已創建的圖層"""
        for layer_id in self.layers:
            QgsProject.instance().removeMapLayer(layer_id)
        self.layers = []

    def check_dependencies(self):
        """檢查必要的依賴庫"""
        if h5py is None:
            QMessageBox.warning(
                self.dlg,
                self.tr('缺少依賴庫'),
                self.tr('需要安裝 h5py 庫以讀取 S-111 文件。\n'
                       '請使用 pip install h5py 命令安裝。')
            )
            return False
        return True

    def select_file(self):
        """打開文件選擇對話框選擇 S-111 文件"""
        filename, _ = QFileDialog.getOpenFileName(
            self.dlg,
            self.tr('選擇 S-111 文件'),
            '',
            self.tr('HDF5 文件 (*.h5 *.hdf5);;所有文件 (*)')
        )
        
        if filename:
            self.dlg.txtFilePath.setText(filename)
            self.current_file = filename
            self.load_s111_file(filename)
            
    def load_s111_file(self, filename):
        """載入 S-111 文件並顯示數據"""
        try:
            # 讀取 S-111 文件
            if self.s111_reader.read_file(filename):
                # 更新元數據顯示
                metadata_text = self.s111_reader.get_metadata_text()
                self.dlg.txtMetadata.setText(metadata_text)
                
                # 設置時間滑塊
                time_steps = len(self.s111_reader.time_points)
                if time_steps > 0:
                    self.dlg.sliderTime.setMinimum(0)
                    self.dlg.sliderTime.setMaximum(time_steps - 1)
                    self.dlg.sliderTime.setValue(0)
                    self.update_time_display(0)
                    
                    # 創建初始時間點的向量圖層
                    self.create_vector_layer(0)
                else:
                    QMessageBox.warning(
                        self.dlg,
                        self.tr('載入錯誤'),
                        self.tr('無法找到時間序列數據。')
                    )
            else:
                QMessageBox.warning(
                    self.dlg,
                    self.tr('載入錯誤'),
                    self.tr('無法解析 S-111 文件。確認文件格式是否正確。')
                )
        except Exception as e:
            QMessageBox.critical(
                self.dlg,
                self.tr('錯誤'),
                self.tr('載入 S-111 文件時發生錯誤: {}').format(str(e))
            )
            
    def create_vector_layer(self, time_index):
        """創建向量圖層顯示指定時間點的海流數據"""
        if not self.s111_reader or not self.s111_reader.surfaces or time_index >= len(self.s111_reader.surfaces):
            return
        
        # 清除現有圖層
        self.clear_layers()
        
        # 獲取當前時間點的數據
        speed, direction = self.s111_reader.surfaces[time_index]
        height, width = speed.shape
        
        # 獲取地理參考信息
        geotransform = self.s111_reader.geotransform
        if not geotransform:
            # 如果沒有地理參考信息，使用簡單的默認值
            geotransform = [0, 1, 0, 0, 0, 1]
        
        # 創建臨時向量圖層
        layer_name = f"S111_Flow_{time_index}"
        vl = QgsVectorLayer("Point?crs=EPSG:4326", layer_name, "memory")
        provider = vl.dataProvider()
        
        # 添加屬性
        provider.addAttributes([
            QgsField("Speed", QVariant.Double),
            QgsField("Direction", QVariant.Double)
        ])
        vl.updateFields()
        
        # 創建海流向量點
        features = []
        
        # 設置採樣步長（可根據數據密度調整）
        step = max(1, min(height, width) // 50)
        
        for y in range(0, height, step):
            for x in range(0, width, step):
                # 檢查是否有有效的流速
                if speed[y, x] > 0:
                    # 計算地理坐標
                    lon = geotransform[0] + x * geotransform[1]
                    lat = geotransform[3] + y * geotransform[5]
                    
                    # 創建一個特徵
                    feature = QgsFeature()
                    feature.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(lon, lat)))
                    feature.setAttributes([float(speed[y, x]), float(direction[y, x])])
                    features.append(feature)
        
        # 添加特徵到圖層
        provider.addFeatures(features)
        vl.updateExtents()
        
        # 設置箭頭符號
        self.apply_arrow_symbology(vl)
        
        # 添加到項目
        QgsProject.instance().addMapLayer(vl)
        self.layers.append(vl.id())
        
        # 縮放到圖層範圍
        if features:
            self.iface.mapCanvas().setExtent(vl.extent())
            self.iface.mapCanvas().refresh()
        
        return vl.id()

    def apply_arrow_symbology(self, layer):
        """應用箭頭符號設置到圖層"""
        # 獲取箭頭大小
        arrow_size = self.dlg.spinArrowSize.value()
        
        # 創建基本標記符號
        symbol = QgsMarkerSymbol.createSimple({})
        
        # 移除默認的簡單標記
        if symbol.symbolLayerCount() > 0:
            symbol.deleteSymbolLayer(0)
        
        # 添加箭頭符號層
        arrow = QgsArrowSymbolLayer()
        arrow.setArrowWidth(arrow_size * 0.5)
        arrow.setArrowStartWidth(arrow_size * 0.5)
        arrow.setHeadLength(arrow_size * 1.5)
        arrow.setHeadThickness(arrow_size)
        arrow.setColor(self.arrow_color)
        symbol.appendSymbolLayer(arrow)
        
        # 設置方向表達式
        # 注意：這裡我們使用 "Direction" 字段，根據您的數據可能需要調整
        prop = QgsProperty.fromExpression("Direction")
        symbol.setDataDefinedAngle(prop)
        
        # 設置大小表達式
        # 使箭頭大小與流速成比例
        prop = QgsProperty.fromExpression(f"min(max(Speed * {arrow_size/2}, {arrow_size}), {arrow_size*5})")
        symbol.setDataDefinedSize(prop)
        
        # 創建渲染器
        renderer = QgsSingleSymbolRenderer(symbol)
        layer.setRenderer(renderer)
        
    def select_color(self):
        """打開顏色選擇對話框"""
        color = QColorDialog.getColor(self.arrow_color, self.dlg)
        if color.isValid():
            self.arrow_color = color
            # 更新所有圖層的箭頭顏色
            self.update_arrow_color(color)
        
    def start_animation(self):
        """開始播放動畫"""
        if not self.s111_reader or not self.s111_reader.surfaces:
            return
            
        if not self.animation_timer:
            self.animation_timer = QTimer()
            self.animation_timer.timeout.connect(self.next_frame)
            
        # 設置動畫速度（可以根據需要調整）
        # 這裡可以添加一個速度控制滑塊到UI中
        interval = 500  # 毫秒，可根據需要調整
        self.animation_timer.start(interval)
        
        # 禁用某些控件
        self.dlg.btnPlay.setEnabled(False)
        self.dlg.btnPause.setEnabled(True)
        self.dlg.btnStop.setEnabled(True)
        
    def pause_animation(self):
        """暫停動畫"""
        if self.animation_timer and self.animation_timer.isActive():
            self.animation_timer.stop()
            
        # 啟用播放按鈕
        self.dlg.btnPlay.setEnabled(True)
        self.dlg.btnPause.setEnabled(False)
        
    def stop_animation(self):
        """停止動畫並重置"""
        if self.animation_timer:
            self.animation_timer.stop()
        
        # 重置到第一幀
        if self.dlg.sliderTime.maximum() >= 0:
            self.dlg.sliderTime.setValue(0)
            
        # 啟用播放按鈕
        self.dlg.btnPlay.setEnabled(True)
        self.dlg.btnPause.setEnabled(False)
        self.dlg.btnStop.setEnabled(False)
        
    def next_frame(self):
        """顯示下一幀"""
        current = self.dlg.sliderTime.value()
        max_value = self.dlg.sliderTime.maximum()
        
        if current < max_value:
            self.dlg.sliderTime.setValue(current + 1)
        else:
            # 循環播放
            self.dlg.sliderTime.setValue(0)
        
    def update_time_display(self, value):
        """更新時間顯示和當前顯示的圖層"""
        if self.s111_reader and self.s111_reader.time_points:
            if 0 <= value < len(self.s111_reader.time_points):
                # 更新時間標籤
                time_str = str(self.s111_reader.time_points[value])
                self.dlg.lblCurrentTime.setText(time_str)
                
                # 更新顯示的圖層
                self.create_vector_layer(value)

    def update_arrow_size(self, size):
        """更新箭頭大小"""
        # 獲取當前時間索引
        current_time = self.dlg.sliderTime.value()
        
        # 重新創建向量圖層以應用新的箭頭大小
        if self.s111_reader and self.s111_reader.surfaces:
            self.create_vector_layer(current_time)

    def update_arrow_color(self, color):
        """更新箭頭顏色"""
        self.arrow_color = color
        
        # 獲取當前時間索引
        current_time = self.dlg.sliderTime.value()
        
        # 重新創建向量圖層以應用新的箭頭顏色
        if self.s111_reader and self.s111_reader.surfaces:
            self.create_vector_layer(current_time)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = S111ViewerDialog()
            
            # 初始化 S-111 讀取器
            self.s111_reader = S111Reader()
            
            # 檢查依賴
            self.check_dependencies()
            
            # 連接按鈕信號
            self.dlg.btnBrowse.clicked.connect(self.select_file)
            self.dlg.btnArrowColor.clicked.connect(self.select_color)
            self.dlg.btnPlay.clicked.connect(self.start_animation)
            self.dlg.btnPause.clicked.connect(self.pause_animation)
            self.dlg.btnStop.clicked.connect(self.stop_animation)
            self.dlg.sliderTime.valueChanged.connect(self.update_time_display)
            self.dlg.spinArrowSize.valueChanged.connect(self.update_arrow_size)

        # show the dialog
        self.dlg.show()